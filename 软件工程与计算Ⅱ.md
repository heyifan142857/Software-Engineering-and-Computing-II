# **软件工程与计算Ⅱ 复习**

---

### **第一、二章**
**名词解释：软件工程**  
定义：应用系统化、规范化、可量化的方法开发、运行和维护软件的学科，涵盖技术、工具和管理流程（IEEE 610.12-1990）。

**简答：1950s~2000s的特点**  
1. **1950s：软硬件一体化**  
   - 软件被视为硬件附属（如ENIAC的接线编程）；  
   - 编程语言萌芽（FORTRAN, COBOL）；  
   - 应用领域限于科学计算、军事（如鱼雷瞄准系统）。  

2. **1960s：软件独立性认知**  
   - 发现软件特殊性：无损耗、易修改、不可见（对比硬件）；  
   - 软件危机爆发（IBM S/360项目延迟），暴露需求规格化困难；  
   - 结构化编程思想萌芽。  

3. **1970s~1980s：结构化方法主导**  
   - 核心公式：`程序 = 算法 + 数据结构`（Wirth理论）；  
   - 工程方法初现：CMM模型、设计模式（如MVC）；  
   - 文档化与过程管理被重视（瀑布模型推广）。  

4. **1990s~2010s：复杂度与规模化**  
   - 万维网/移动互联网催生大型系统（Jones数据：100万LOC项目缺陷清除成本占18%，P75）；  
   - 重量级方法论兴起（RUP），但敏捷方法应对变化需求（Scrum, XP）；  
   - 关键认知：**软件开发 ≠ 编程**（文档、协作、管理成本远超编码）。  

5. **2010s至今：云原生与DevOps**  
   - 技术栈：容器化（Docker）、微服务、Serverless（FaaS/BaaS）；  
   - 开发范式：DevOps文化（自动化CI/CD）、云原生架构（Kubernetes）；  
   - 新挑战：AI工程化（如MLOps）、大规模分布式系统质量保障。  

---

### **第四章 项目启动**
**1. 如何管理团队？**
- **团队特征**：共同目标、共担责任、技能互补、明确结构（主程序员/民主/开放团队）。
- **管理措施**：
  - **建立团队章程**：明确会议规则、沟通方式、工作时间（如示例中的请假惩罚、投票决策）。
  - **激励因素**：根据角色（开发/管理/普通成员）侧重不同激励（如成就感、责任感、工作乐趣）。
  - **避免团队杀手**：防范官僚主义、地理分散、虚假截止日期等（参考DeMarco1999）。
- **实验应用**：在实验中通过制定团队章程（如严格考勤、文档共享规则）和角色分工（需求分析师、测试人员等）实现高效协作。

**2. 团队结构有哪几种？**
- **主程序员团队**：核心主程序员主导，其他成员辅助（如主程序员+备份程序员+文档员）。
- **民主团队**：平等协作，集体决策（适合创意型项目）。
- **开放团队**：松散结构，动态分工（如开源社区）。
- **实验选择**：实验中可能采用民主团队（如小组投票决策）或主程序员团队（复杂模块由主程序员负责）。

**3. 质量保障措施**
- **质量模型**（ISO/IEC 9126）：功能性、可靠性、可维护性等。
- **活动**：
  - **评审**：需求/设计/代码评审（如实验中对SRS文档的审查会议）。
![评审过程](./image/评审过程.png)
  - **测试**：单元测试、持续集成（实验中通过Jenkins自动化测试）。
  - **质量度量**：代码行数、缺陷密度（如实验中使用SonarQube分析代码质量）。
- **实验结合**：在需求阶段进行评审，开发阶段实施测试驱动开发（TDD），发布前进行配置审计。

**4. 配置管理活动**
- **定义**
  用技术的和管理的指导和监督方法，来标识和说明配置项的功能和物理特征，控制对这些特征的变更，记录和报告变更处理及其实现状态，并验证与规格需求的⼀致性
- **核心活动**：
  1. **标识配置项**：确定需管理的文档/代码（如实验中的需求文档、源码）。
  2. **版本控制**：Git分支策略（Master/Develop/Feature分支）。
  3. **变更控制**：提交变更请求表单并评审（如实验中使用GitHub Issues跟踪变更）。
![变更控制过程](./image/变更控制过程.png)
  4. **配置审计**：验证基线一致性（如实验发布前检查文档与代码匹配性）。
  5. **状态报告**：记录版本发布信息（如实验中的Release Notes）。
  6. **软件发布管理**： 软件发布管理就是要创建和发布可用的产品。
- **实验工具**：使用Git管理代码，通过标签（Tag）标记基线版本。

**5. 结合实验的示例（2010年题目）**
**项目质量保障活动**：
1. **需求阶段**：需求评审会议，检查SRS文档完整性。
2. **设计阶段**：体系结构评审，使用UML模型验证设计合理性。
3. **实现阶段**：代码评审（Peer Review）+ SonarQube静态分析。
4. **测试阶段**：单元测试（JUnit）+ 持续集成（Jenkins自动构建）。
5. **发布阶段**：配置审计（检查所有交付物是否纳入基线）。


---

### **第五章 需求工程**
- **1.名词解释：需求**  
  - ⑴用户为了解决问题或达到某些目标所需要的条件或能力；
  - ⑵系统或系统部件为了满足合同、标准、规范或其它正式文档所规定的要求而需要具备的条件或能力；
  - ⑶对⑴或⑵中的一个条件或一种能力的一种文档化表述。
- **2.需求的三个层次**  
  - **业务需求**（目标，如“提高借书效率”）。  
  - **用户需求**（用户视角，如“借书人可预约图书”）。  
  - **功能需求**（系统实现，如“系统需记录预约日期”）。  

- **3.实例：图书管理系统**  
  - 业务需求：优化图书流通。  
  - 用户需求：研究生可查看导师推荐书目。  
  - 功能需求：系统存储导师关联字段。  

- **4.需求类型**  
  - **功能需求（Functional Requirement）**
  和系统主要工作相关的需求，即在不考虑物理约束的情况下，用户希望系统所能够执行的活动，这些活动可以帮助用户完成任务。功能需求主要表现为系统和环境之间的行为交互。
  - **性能需求（Performance Requirement）**
  系统整体或系统组成部分应该拥有的性能特征，例如CPU使用率、内存使用率等。
    - *所有的用户查询都必须在10秒内完成*
    - *系统应该能够存储至少100万个销售信息。*
    - *系统应该允许50个营业服务器同时从集中服务器上进行数据的上传或下载。*
    - *监测到病人异常后，监控器必须在0.5秒内发出警报。*
  - **质量属性（Quality Attribute）**
  系统完成工作的质量，即系统需要在一个“好的程度”上实现功能需求，例如可靠性程度、可维护性程度等。
    - *在进行数据的下载和上传中，如果网络故障，系统不能出现故障。*
    - *系统的可用性要达到98%。*
    - *VIP顾客只能查看自己的个人信息和购买记录；*
    - *收银员只能查看，不能修改、删除VIP顾客的信息。*
    - *如果系统要增加新的特价类型，要能够在2个人月内完成。(可维护性)*
    - *集中服务器要能够在1人月内从Window 7操作系统更换到Solaris 10操作系统。（可移植性）*
  - **对外接口（External Interface）**
  系统和环境中其他系统之间需要建立的接口，包括硬件接口、软件接口、数据库接口等等。
  - **约束**
  进行系统构造时需要遵守的约束，例如编程语言、硬件设施等 
    - *系统要使用Java语言进行开发。*

---

### **第六章 建模**
- **1.用例图**  
  - **基本要素**
    用例、参与者、关系和系统边界
![超市销售系统用例](./image/超市销售系统用例.png)
  - **用例模板**
    |项目|内容描述|
    |:---:|:---:|
    |ID|用例的标识|
    |名称|对用例内容的精确描述，体现了用例所描述的任务|
    |参与者|描述系统的参与者和每个参与者的目标|
    |触发条件|标识启动用例的事件，可能是系统外部的事件，也可能是系统内部的事件，还可能是正常流程的第一个步骤|
    |前置条件|用例能够正常启动和工作的系统状态条件|
    |后置条件|用例执行完成后的系统状态条件|
    |正常流程|在常见和符合预期的条件下，系统与外界的行为交互序列|
    |扩展流程|用例中可能发生的其他场景|
    |特殊需求|和用例相关的其他特殊需求，尤其是非功能性需求|

    |项目|内容描述|
    |:---:|:---|
    |ID|UC1|
    |名称|销售处理|
    |参与者|收银员，目标是快速、正确地完成商品销售，尤其不要出现支付错误|
    |触发条件|顾客携带商品到达销售点|
    |前置条件|收银员必须已经被识别和授权|
    |后置条件|存储销售记录，包括购买记录、商品清单、赠送清单和付款信息；更新库存和会员积分；打印收据|
    |正常流程|1. 如果是会员，收银员输人客户编号<br>2.系统显示会员信息，包括姓名与积分<br>3.收银员输人商品标识<br>4.系统记录并显示商品信息，商品信息包括商品标识、描述、数量、价格、特价（如果有商品特价策略）和本项商品总价<br>5. 系统显示已购人的商品清单，商品清单包括商品标识、描述、数量、价格、特价、各项商品总价和所有商品总价收银员重复3~5步，直到完成所有商品的输人<br>6.收银员结束输人，系统根据总额特价策略计算并显示总价<br>7.系统根据商品赠送策略和总额赠送策略计算并显示赠品清单，赠品清单包括各项赠品的标识、描述与数量<br>8.收银员请顾客支付账单<br>9. 顾客支付，收银员输人收取的现金数额<br>10.系统给出应找的余额，收银员找零<br>11.收银员结束销售，系统记录销售信息、商品清单、赠品清单和账单信息，并更新库存<br>12.系统打印收据|
    |扩展流程|1a.非法客户编号：<br>1. 系统提示错误并拒绝输人<br>3a.非法标识：<br>1. 系统提示错误并拒绝输人<br>3b.有多个具有相同商品类别的商品（如5把相同的雨伞）<br>1. 收银员可以手工输人商品标识和数量5-8a.顾客要求收银员从已输人的商品中去掉一个商品：<br>1. 收银员输人商品标识并将其删除<br>1a. 非法标识<br>1.系统显示错误并拒绝输人<br>2. 返回正常流程第5步<br>5-8b.顾客要求收银员取消交易<br>1. 收银员在系统中取消交易<br>9a.会员使用积分<br>1. 系统显示可用的积分余额<br>2. 收银员输人使用的积分数额，每50个积分等价于1元人民币<br>3.系统显示剩余的积分和现金数额<br>4.收银员输人收取的现金数额<br>11a.会员<br>1.系统记录销售信息、商品清单、赠品清单和账单信息，并更新库存<br>2.计算并更新会员积分，累计积分总额并更新可使用的积分和现金数额|
    |特殊需求|1.系统显示的信息要在1米之外能看清<br>2.因为在将来的一段时间内，商店都不打算使用扫描仪设备，所以为输人方便，要使用5位0～9数字的商品标识格式。将来如果商店采购了扫描仪，商品标识格式要修改为标准要求：13位0～9的数字|
- **2.分析类图（概念类图）（只有属性，没有方法）** 
  - **基本元素**
    - 对象
      - 标示符
      - 状态
      - 行为
    - 类
      - 对象集合的抽象
![类与对象](./image/类与对象.png)   
    - 链接（link）（dependency）
      - 对象之间的互相协作的关系
      - 描述了对象之间的物理或业务联系
    - 关联
      - 对象之间链接的抽象
      - 聚合与组合
![关联](./image/关联.png)
    - 继承
      - 泛化关系
![继承](./image/继承.png) 

  - **建立概念类图**
      - 识别候选类
![](./image/候选类识别.png)
      - 确立概念类
![](./image/确定概念类.png) 
      - 识别关联
![](./image/关联分析.png) 
      - 识别重要属性
![](./image/添加属性.png) 
- **3.系统顺序图（交互图）** 
  描述的是单个用例的典型场景
  opt 是可选项
  loop 是循环
  alt 多选⼀
![](./image/顺序图.png)
![](./image/顺序图示例.png)
- **4.状态图** 
![](./image/状态图.png)
![](./image/状态图示例.png)
---

### **第七章 需求规格说明**
软件需求规格说明文档描述了软件系统的解决方案
![](./image/规格文档.png)
- **1.技术文档写作要点**
  - 简洁
  - 精确
  - 易读（查询）
    - 1、有效使用引言、目录、索引等能够增强文档易读性的方法。
    - 2、使用系统化的方式组织内容信息，提供文档内容的可读性。
  - 易修改
- **2.需求书写要点**
  - 使用用户术语
  - 可验证
    - *R1：用户查询的界面应该友好。*
    - *R2：用户完成任何一个查询任务时的鼠标点击数都不能超过5次。*
  - 可行性
    - *R3：系统必须持续可用，即每周7天，每天24小时都是可用的。* 
- **3.需求规格说明文档书写要点**
  - 充分利用标准的文档模版，保持所有内容位置得当
  - 保持文档内的需求集具有完备性和一致性。
  - 为需求划分优先级 
- **4.度量需求功能点**
![](./image/功能点测度.png)  
---

### **第八章 软件设计**
**1.名词解释：软件设计**  
软件设计是关于软件对象的设计，是一种设计活动，自然具有设计的普遍特性。软件设计既指软件对象实现的规格说明(specification)，也指产生这个规格说明的过程。

**2.软件设计的核心思想**  
分解与抽象
![](./image/分解与抽象.png)


**3.三个设计层次**  
1. **低层设计**：将基本的语言单位（类型与语句），组织起来，建立高质量的 数据结构+算法
*常见设计场景：数组的使用，链表的使用，内存的使用，遍历算法，递归算…*
2. **中层设计**：模块划分与接口定义。  
3. **高层设计**：类/方法级实现（如UML类图）。
![](./image/软件设计的分层.png)  

---

### **第九、十章 体系结构**
**1.体系结构的概念**
一个软件系统的体系结构规定了系统的计算部件和部件之间的交互。
软件体系结构={部件（component）,连接件（connector）,配置（configuration）}

**2.体系结构的风格以及优缺点**  
- **主程序/子程序风格** 
![](./image/主程序子程序风格.png)
  - 优点：
    - 流程清晰,易于理解。
    - 强控制性。
  - 缺点：
    - 程序调用是⼀种强耦合的连接方式,非常依赖交互方的接口规格,这会使得系统难以修改和复用。
    - 程序调用的连接方式限制了各部件之间的数据交互,可能会使得不同部件使用隐含的共享数据交流,产生不必要的公共耦合,进而破坏它的“正确性”控制能力。 
- **面向对象式风格** 
![](./image/面向对象式风格.png) 
  - 优点：
    - 内部实现的可修改性。
    - 易开发、易理解、易复用的结构组织。
  - 缺点：
    - 接口的耦合性。
    - 标识(Identity)的耦合性。
    - 副作用。
      - 面向对象式风格借鉴了面向对象的思想，也引入了面向对象的副作用，因此更难实现程序的“正确性”。例如，如果A和B都使用对象C,那么B对C的修改可能会对A产生未预期的影响。再例如对象的重入(Reentry)问题:如果A的方法f0调用了B的方法p0,而p0又调用了A的另一方法q0,那么就可能使得q0失败,因为在q0开始执行时,A正处于f0留下的执行现场，这个现场可能是数据不一致的。
- **分层风格** 
![](./image/分层风格.png)
  - 优点：
    - 设计机制清晰，易于理解。
    - 支持并行开发。
    - 更好的可复用性与内部可修改性。
  - 缺点：
    - 交互协议难以修改。
    - 性能损失。
    - 难以确定层次数量和粒度。
- **MVC** 
模型-视图-控制（Model-View-Control，MVC）风格。
![](./image/MVC.png)
  - 优点：
    - 易开发性。视图和控制的可修改性。
    - 模型封装了系统的业务逻辑，所以是三种类型中最为复杂的系统部件。MVC中模型是相对独立的，所以对视图实现和控制实现的修改不会影响到模型实现。再考虑到业务逻辑通常比业务表现和控制逻辑更加稳定，所以MVC具有一定的可修改性优势。
    - 适宜于网络系统开发的特征。MVC不仅允许视图和控制的可修改性，而且其对业务逻辑、表现和控制的分离使得一个模型可以同时建立并保持多个视图，这非常适用于网络系统开发。
  - 缺点：
    - 复杂性。MVC将用户任务分解成了表现、控制和模型三个部分，这增加了系统的复杂性，不利于理解任务实现。
    - 模型修改困难。视图和控制都要依赖于模型，因此，模型难以修改。

**3.体系结构设计过程**  
1）分析关键需求和项目约束；
2）选择体系结构风格；
3）进行软件体系结构逻辑（抽象）设计；
4）依赖逻辑设计进行软件体系结构物理（实现）设计；
5）完善软件体系结构设计；
6）定义构件接口；
7）迭代过程3）～6）。

**4.包的原则**
- **包的设计原则概述**
包（Package）是组织类和模块的基本单元，良好的包设计能提升代码的可维护性、可复用性和可扩展性。
*康威定律："设计系统的架构受制于产生这些设计的组织的沟通结构。"* 
包的原则主要分为两类：
  1. **内聚性原则**：指导如何将类划分到包中（Cohesion）。
  2. **耦合性原则**：指导包之间的依赖关系（Coupling）。
- **1. 内聚性原则**
  - **(1) 共同封闭原则（Common Closure Principle, CCP）**
    - **核心思想**：将**同时修改的类放在同一个包中**，减少变更的影响范围。
    - **目的**：降低维护成本，确保修改时只需重新编译和发布少数包。
    - **示例**：
      - 数据持久化相关的类（如数据库连接、PO类）应放在同一包中。
      - 接口数据传输对象（如VO）应集中管理，因为它们常因需求变更而一起修改。
    - **优势**：符合“单一职责”，包内高内聚，包间低耦合。

  - **(2) 共同重用原则（Common Reuse Principle, CRP）**
    - **核心思想**：**一起被重用的类应放在同一个包中**。
    - **目的**：避免用户依赖不必要的类，减少冗余依赖。
    - **示例**：
      - 工具类（如`StringUtils`）应独立成包，用户只需依赖实际用到的工具。
      - 若一个包中的某些类很少被一起使用，应拆分为更小的包。
    - **优势**：提升复用性，减少包体积。

  - **(3) 重用发布等价原则（Reuse-Release Equivalency Principle, REP）**
    - **核心思想**：**包的复用单元应等同于发布单元**。
    - **目的**：确保复用的包有明确的版本管理和稳定性。
    - **示例**：
      - 通用工具包（如`commons-lang`）需独立版本控制，用户通过版本号引用。
      - 避免直接依赖未发布的内部包。
- **2. 耦合性原则**
  - **(4) 无环依赖原则（Acyclic Dependencies Principle, ADP）**
    - **核心思想**：**包之间的依赖关系必须是无环的有向图（DAG）**。
    - **目的**：防止循环依赖导致的编译、测试和发布困难。
    - **解决方案**：
      - **方法1**：提取公共类到新包（如将共享接口抽离）。
      - **方法2**：依赖倒置（DIP），通过接口解耦（如`Sales`依赖`Member`的抽象接口）。
    - **示例**：
      - MVC架构中，若`Controller`依赖`Service`，`Service`又反向依赖`Controller`，需通过接口解耦。

  - **(5) 稳定依赖原则（Stable Dependencies Principle, SDP）**
    - **核心思想**：**依赖方向应指向更稳定的包**。
    - **稳定性度量**：
      - **不稳定性（I）**：`I = Ce / (Ca + Ce)`  
        - `Ca`（输入耦合）：依赖该包的包数量。  
        - `Ce`（输出耦合）：该包依赖的其他包数量。  
        - `I=0`（最稳定，如数据库层）；`I=1`（最不稳定，如工具类）。
    - **示例**：
      - 数据库包应保持高稳定性（低`I`），避免频繁变更影响上层。

  - **(6) 稳定抽象原则（Stable Abstractions Principle, SAP）**
    - **核心思想**：**稳定的包应是抽象的**（通过接口或抽象类扩展），不稳定的包应是具体的。
    - **抽象性度量**：`A = Na / Nc`（抽象类数 / 总类数）。
    - **理想状态**：稳定包（低`I`）应有高抽象性（高`A`）。
    - **示例**：
      - 数据库操作应依赖`DataSource`接口，而非具体的`MySQLDataSource`。

**5.体系结构构建之间接口的定义**
![](./image/体系结构构建之间接口的定义.png)

**6.体系结构开发集成测试用例**
当体系结构中原型各个模块的代码都编写完成并经过单元测试之后，需要将所有模块组合起来形成整个软件原型系统，这就是集成。
- 大爆炸式
- 增量式
  - 自顶向下式
![](./image/自顶向下.png)
  - 自底向上式
![](./image/自底向上.png)
  - 三明治式
  - 持续集成
  
---

### **第十一章 人机交互**
**可用性**
易学性、易记性、效率、出错率和主观满意度  
在易用性的不同维度中，易学性和效率是存在冲突的

**人机交互设计的人类因素**
- **精神模型**
  精神模型就是用户进行人机交互时头脑中的任务模型。人机交互设计需要依据精神模型进行隐喻（metaphor）设计。隐喻又被称为视觉隐喻，是视觉上的图像，但会被用户映射为业务事物。用户在识别图像时，会依据隐喻将控件功能与已知的熟悉事物联系起来，形成任务模型。隐喻本质上是在用户已有知识的基础上建立一组新的知识，实现界面视觉提示和系统功能之间的知觉联系。(右边更好，四个开关对应相匹配的灶头)
![](./image/隐喻设计.png)
- **差异性**
  任务模型是人机交互设计的重要依据，但是不同用户群体的任务模型是有差异的，所以对他们的人机交互设计也要有差异。按照用户群体自身的特点，可以将其划分为新手用户、专家用户和熟练用户。

**人机交互设计的计算机因素**
- **可视化设计**

**5个界面设计的注意事项及解释**

  1. **一致性（Consistency）**  
     - **解释**：界面元素（如按钮、图标、颜色、术语）应在整个系统中保持一致。例如，相同功能的按钮应使用相同的标签和样式。一致性减少用户的学习成本，避免混淆。  
     - **违反示例**：同一系统中，“保存”按钮有时显示为“确认”，有时为“提交”，违反了术语一致性。

  2. **反馈（Feedback）**  
     - **解释**：系统应及时响应用户操作，提供明确的状态反馈（如加载动画、成功提示、错误消息）。例如，提交表单后显示“提交成功”或“网络错误”。  
     - **违反示例**：用户点击按钮后无任何反应，导致重复操作或不确定是否生效。

  3. **导航清晰（Clear Navigation）**  
     - **解释**：用户应能轻松找到所需功能，通过菜单、面包屑、搜索栏等明确路径引导。例如，电商网站的层级分类和返回按钮。  
     - **违反示例**：复杂多层菜单隐藏关键功能，用户需多次点击才能找到目标页面。

  4. **减少记忆负担（Reduce Memory Load）**  
     - **解释**：避免要求用户记忆复杂信息，通过默认值、历史记录、可视化提示辅助操作。例如，自动填充表单或显示最近访问记录。  
     - **违反示例**：系统要求用户手动输入长串代码且无历史记录参考。

  5. **容错性（Error Prevention & Recovery）**  
     - **解释**：预防错误（如输入验证）并提供简单恢复方式（如撤销操作、明确错误提示）。例如，删除文件前弹出确认对话框。  
     - **违反示例**：删除操作无确认提示，且未提供回收站功能，导致数据不可恢复。

**例子：违反的界面设计原则**

假设例子是一个表单设计：  
- **问题1**：表单无自动保存功能，用户需手动点击“保存”按钮，且未提示未保存内容。  
  - **违反原则**：反馈不足（未提示未保存状态）、容错性差（易丢失数据）。  
- **问题2**：表单标签使用专业术语（如“PID”代替“用户ID”），且必填项未标红。  
  - **违反原则**：未考虑用户精神模型（术语不符认知）、一致性差（必填项无统一标识）。  

**人机交互设计的交互性**
- **导航**
  软件系统的导航有全局结构和局部结构两种方式[Dix2003]：
    - 全局结构按照任务模型将软件产品的功能组织起来，并区分不同的重要性和主题提供给不同的用户。全局结构常用的导航控件包括窗口、菜单、列表、快捷方式、热键等。全局结构的设计主要以功能分层和任务交互过程为依据。
    - 局部结构通过安排界面布局细节，制造视觉上的线索来给用户提供导航。局部结构常用的导航控件包括可视化控件布局与组合、按钮设置、文本颜色或字体大小等。局部结构的设计主要以用户关注的任务细节为依据。
![](./image/导航设计.png)
- **反馈**
  - 好的人机交互设计需要对用户行为进行反馈，让用户能够意识到行为的结果。
  - 反馈的目的是提示用户交互行为的结果，但不能打断用户工作时的意识流。
  - 对时间的控制也是反馈设计的一个要点，它既要考虑计算时间，又要考虑用户的思考和反应时间。
- **协作式设计**
  - **黄金原则（P70-P72）**：用户控制、减少记忆负担、一致性。  
  - **人因研究（P25-P26）**：考虑用户认知限制（如7±2记忆原则）。  
  - **可视化设计（P33-P36）**：图标和布局需直观，避免暴露内部技术细节。  

---

### **第十三章 耦合与内聚**
**名词解释**  
- **耦合**：模块间依赖程度（低耦合更优）。  
- **内聚**：模块内部功能相关性（高内聚更优）。  

**示例分析**  
- **高耦合**：模块A直接修改模块B的全局变量。  
- **低内聚**：一个类同时处理用户登录和订单计算。  

---

### **第十五章 设计原则**
**里氏替换原则例题**  
1. **MyStack继承Vector**：违反LSP（栈不应暴露Vector的所有方法）。  
   **修正**：改用组合，内部封装Vector。  
2. **Employee继承Person**：合理，符合“is-a”关系。  

---

### **第十九章 测试**
**白盒测试方法比较**  
- **语句覆盖**：覆盖所有代码行。  
- **分支覆盖**：覆盖所有if-else路径。  
- **路径覆盖**：覆盖所有执行路径（最全面但成本高）。  

**测试用例设计**  
- **单元测试**：Mock `Account`类，测试`withdraw()`方法。  
- **集成测试**：验证`ATM`与`SecuritySystem`的PIN校验交互。  

---

### **第二十二章 生命周期模型**
**适用场景**  
- **瀑布模型**：需求明确（如航天软件）。  
- **敏捷模型**：需求多变（如互联网产品）。  
- **螺旋模型**：高风险项目（如金融系统）。  

---

**注**：以上为精简版答案，实际考试需结合具体实验和示例展开。建议补充图表（如UML图）和代码片段以增强说服力。