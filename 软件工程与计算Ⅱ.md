# **软件工程与计算Ⅱ 复习**

---

### **第一、二章**
**名词解释：软件工程**  
定义：应用系统化、规范化、可量化的方法开发、运行和维护软件的学科，涵盖技术、工具和管理流程（IEEE 610.12-1990）。

**简答：1950s~2000s的特点**  
1. **1950s：软硬件一体化**  
   - 软件被视为硬件附属（如ENIAC的接线编程）；  
   - 编程语言萌芽（FORTRAN, COBOL）；  
   - 应用领域限于科学计算、军事（如鱼雷瞄准系统）。  

2. **1960s：软件独立性认知**  
   - 发现软件特殊性：无损耗、易修改、不可见（对比硬件）；  
   - 软件危机爆发（IBM S/360项目延迟），暴露需求规格化困难；  
   - 结构化编程思想萌芽。  

3. **1970s~1980s：结构化方法主导**  
   - 核心公式：`程序 = 算法 + 数据结构`（Wirth理论）；  
   - 工程方法初现：CMM模型、设计模式（如MVC）；  
   - 文档化与过程管理被重视（瀑布模型推广）。  

4. **1990s~2010s：复杂度与规模化**  
   - 万维网/移动互联网催生大型系统（Jones数据：100万LOC项目缺陷清除成本占18%，P75）；  
   - 重量级方法论兴起（RUP），但敏捷方法应对变化需求（Scrum, XP）；  
   - 关键认知：**软件开发 ≠ 编程**（文档、协作、管理成本远超编码）。  

5. **2010s至今：云原生与DevOps**  
   - 技术栈：容器化（Docker）、微服务、Serverless（FaaS/BaaS）；  
   - 开发范式：DevOps文化（自动化CI/CD）、云原生架构（Kubernetes）；  
   - 新挑战：AI工程化（如MLOps）、大规模分布式系统质量保障。  

---

### **第四章 项目启动**
**1. 如何管理团队？**
- **团队特征**：共同目标、共担责任、技能互补、明确结构（主程序员/民主/开放团队）。
- **管理措施**：
  - **建立团队章程**：明确会议规则、沟通方式、工作时间（如示例中的请假惩罚、投票决策）。
  - **激励因素**：根据角色（开发/管理/普通成员）侧重不同激励（如成就感、责任感、工作乐趣）。
  - **避免团队杀手**：防范官僚主义、地理分散、虚假截止日期等（参考DeMarco1999）。
- **实验应用**：在实验中通过制定团队章程（如严格考勤、文档共享规则）和角色分工（需求分析师、测试人员等）实现高效协作。

**2. 团队结构有哪几种？**
- **主程序员团队**：核心主程序员主导，其他成员辅助（如主程序员+备份程序员+文档员）。
- **民主团队**：平等协作，集体决策（适合创意型项目）。
- **开放团队**：松散结构，动态分工（如开源社区）。
- **实验选择**：实验中可能采用民主团队（如小组投票决策）或主程序员团队（复杂模块由主程序员负责）。

**3. 质量保障措施**
- **质量模型**（ISO/IEC 9126）：功能性、可靠性、可维护性等。
- **活动**：
  - **评审**：需求/设计/代码评审（如实验中对SRS文档的审查会议）。
  - **测试**：单元测试、持续集成（实验中通过Jenkins自动化测试）。
  - **度量**：代码行数、缺陷密度（如实验中使用SonarQube分析代码质量）。
- **实验结合**：在需求阶段进行评审，开发阶段实施测试驱动开发（TDD），发布前进行配置审计。

**4. 配置管理活动**
- **核心活动**：
  1. **标识配置项**：确定需管理的文档/代码（如实验中的需求文档、源码）。
  2. **版本控制**：Git分支策略（Master/Develop/Feature分支）。
  3. **变更控制**：提交变更请求表单并评审（如实验中使用GitHub Issues跟踪变更）。
  4. **配置审计**：验证基线一致性（如实验发布前检查文档与代码匹配性）。
  5. **状态报告**：记录版本发布信息（如实验中的Release Notes）。
- **实验工具**：使用Git管理代码，通过标签（Tag）标记基线版本。

**5. 结合实验的示例（2010年题目）**
**项目质量保障活动**：
1. **需求阶段**：需求评审会议，检查SRS文档完整性。
2. **设计阶段**：体系结构评审，使用UML模型验证设计合理性。
3. **实现阶段**：代码评审（Peer Review）+ SonarQube静态分析。
4. **测试阶段**：单元测试（JUnit）+ 持续集成（Jenkins自动构建）。
5. **发布阶段**：配置审计（检查所有交付物是否纳入基线）。


---

### **第五章 需求工程**
**名词解释：需求**  
用户对系统功能的期望和约束，分为三个层次：  
1. **业务需求**（目标，如“提高借书效率”）。  
2. **用户需求**（用户视角，如“借书人可预约图书”）。  
3. **功能需求**（系统实现，如“系统需记录预约日期”）。  

**实例：图书管理系统**  
- 业务需求：优化图书流通。  
- 用户需求：研究生可查看导师推荐书目。  
- 功能需求：系统存储导师关联字段。  

**需求类型**  
- **功能需求**（系统做什么，如“支持借书”）。  
- **非功能需求**（性能、安全性，如“响应时间<2秒”）。  
- **约束**（技术限制，如“使用MySQL数据库”）。  

---

### **第六章 建模**
**图书馆系统用例图**  
- **参与者**：借书人（教职工/研究生/本科生）、管理员、外部数据库。  
- **用例**：借书、还书、预约、检索书目、生成报表。  

**ATM系统分析类图**  
- 类：`ATM`、`Account`、`Transaction`、`SecuritySystem`。  
- 属性：`ATM`包含`screen`、`cardReader`；`Account`含`balance`。  

---

### **第七章 需求规格说明**
**为什么需要需求规格说明？**  
- 明确系统边界，避免歧义，作为开发和验收依据。  
- **实验示例**：实验二中未明确“预约优先级”规则导致功能冲突。  

**功能测试用例设计**  
- **示例**：测试“借书”功能。  
  - 输入：有效借书人ID、可借图书。  
  - 预期输出：借书记录成功，库存减少。  

---

### **第八章 软件设计**
**名词解释：软件设计**  
将需求转化为系统蓝图的过程，包括架构、接口和组件设计。  

**三个设计层次**  
1. **架构设计**：系统组件与交互（如分层架构）。  
2. **高层设计**：模块划分与接口定义。  
3. **详细设计**：类/方法级实现（如UML类图）。  

---

### **第九、十章 体系结构**
**分层风格优缺点**  
- **优点**：解耦、易维护。  
- **缺点**：性能损耗（跨层调用）。  

**社会保险录入接口示例**  
```java
// 展示层包
package com.ui;
interface ISocialInsuranceUI {
    void displayInputForm();
}

// 逻辑层包
package com.logic;
interface ISocialInsuranceLogic {
    void submitData(String jsonData);
}
```

---

### **第十一章 人机交互**
**界面设计原则**  
1. **一致性**（相同操作产生相似结果）。  
2. **反馈**（用户操作后系统即时响应）。  
3. **简化导航**（减少点击层次）。  
4. **错误预防**（如输入验证）。  
5. **符合精神模型**（如购物车图标代表结算）。  

---

### **第十三章 耦合与内聚**
**名词解释**  
- **耦合**：模块间依赖程度（低耦合更优）。  
- **内聚**：模块内部功能相关性（高内聚更优）。  

**示例分析**  
- **高耦合**：模块A直接修改模块B的全局变量。  
- **低内聚**：一个类同时处理用户登录和订单计算。  

---

### **第十五章 设计原则**
**里氏替换原则例题**  
1. **MyStack继承Vector**：违反LSP（栈不应暴露Vector的所有方法）。  
   **修正**：改用组合，内部封装Vector。  
2. **Employee继承Person**：合理，符合“is-a”关系。  

---

### **第十九章 测试**
**白盒测试方法比较**  
- **语句覆盖**：覆盖所有代码行。  
- **分支覆盖**：覆盖所有if-else路径。  
- **路径覆盖**：覆盖所有执行路径（最全面但成本高）。  

**测试用例设计**  
- **单元测试**：Mock `Account`类，测试`withdraw()`方法。  
- **集成测试**：验证`ATM`与`SecuritySystem`的PIN校验交互。  

---

### **第二十二章 生命周期模型**
**适用场景**  
- **瀑布模型**：需求明确（如航天软件）。  
- **敏捷模型**：需求多变（如互联网产品）。  
- **螺旋模型**：高风险项目（如金融系统）。  

---

**注**：以上为精简版答案，实际考试需结合具体实验和示例展开。建议补充图表（如UML图）和代码片段以增强说服力。